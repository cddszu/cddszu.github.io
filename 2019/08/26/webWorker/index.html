<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="webWokrer"><meta name="keywords" content><meta name="author" content="东东"><meta name="copyright" content="东东"><title>webWokrer | 木皆白告</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、webWokrer介绍"><span class="toc-number">1.</span> <span class="toc-text">一、webWokrer介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-web-worker需要注意的几个小点"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">1.1 web worker需要注意的几个小点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（1）同源策略"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">（1）同源策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（2）全局对象限制"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">（2）全局对象限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（3）通信限制"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">（3）通信限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（4）文件限制"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">（4）文件限制</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Worker的基础用法"><span class="toc-number">2.</span> <span class="toc-text">二、Worker的基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1主线程"><span class="toc-number">2.1.</span> <span class="toc-text">2.1主线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Worker线程"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Worker线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-错误处理"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-subWorker"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 subWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-引入脚本与库"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 引入脚本与库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-SharedWorker"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 SharedWorker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Worker的数据通信"><span class="toc-number">3.</span> <span class="toc-text">三、Worker的数据通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Worker的线程问题"><span class="toc-number">4.</span> <span class="toc-text">四、Worker的线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-进程和线程"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-worker的线程"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 worker的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-worker异步和js异步有什么区别"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 worker异步和js异步有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-连续创建多个Worker线程"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 连续创建多个Worker线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-创建Worker线程有上限么"><span class="toc-number">4.5.</span> <span class="toc-text">4.4 创建Worker线程有上限么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、嵌入式worker"><span class="toc-number">5.</span> <span class="toc-text">五、嵌入式worker</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://b-ssl.duitang.com/uploads/item/201711/10/20171110225150_ym2jw.jpeg"></div><div class="author-info__name text-center">东东</div><div class="author-info__description text-center">帅气的小哥哥</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">木皆白告</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">webWokrer</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-26</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="一、webWokrer介绍"><a href="#一、webWokrer介绍" class="headerlink" title="一、webWokrer介绍"></a>一、<code>webWokrer</code>介绍</h2><p>javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。</p>
<p>web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，子线程不会影响到主线程程序的运行，这样就能提高对计算机的运算能力的利用。</p>
<h5 id="1-1-web-worker需要注意的几个小点"><a href="#1-1-web-worker需要注意的几个小点" class="headerlink" title="1.1 web worker需要注意的几个小点"></a>1.1 web worker需要注意的几个小点</h5><h5 id="（1）同源策略"><a href="#（1）同源策略" class="headerlink" title="（1）同源策略"></a>（1）同源策略</h5><p>webWorker脚本必须和主线程的脚本同源</p>
<h5 id="（2）全局对象限制"><a href="#（2）全局对象限制" class="headerlink" title="（2）全局对象限制"></a>（2）全局对象限制</h5><p>webWorker脚本所在的全局对象，与主线程不一致，无法使用：</p>
<p><code>docement</code>、 <code>window</code>、 <code>parent</code>、 <code>DOM</code>对象，这样即代表着webWorker不能更新DOM节点；并且webWorker不能执行<code>alert()</code>方法和<code>confirm()</code>方法，</p>
<p>但是可以使用：</p>
<p><code>navigator</code>、<code>location</code>（只读）、<code>XMLHttpRequest</code>（可以创建AJAX请求） 、<code>setTimeout/setInterval</code> 方法、<code>Application Cache</code>、通过 <code>importScripts()</code>方法加载其他脚本、创建新的 Web Worker</p>
<h5 id="（3）通信限制"><a href="#（3）通信限制" class="headerlink" title="（3）通信限制"></a>（3）通信限制</h5><p>Worker线程和主线程不在同一个上下文环境，之间不能直接通信，只能通过消息事件进行通信，这里的传递只是进行值传递（拷贝传递），而不是进行引用地址传递，这种方法叫做结构化克隆传递数据（structured cloning）。</p>
<p>在进行二进制传递的时候，是使用可转让对象传递数据（transferable objects），即主线程把二进制数据直接转让给了子进程，此时主进程将无法使用此部分二进制数据，反过来亦如此。这是为了防止出现多个线程同时修改数据的问题。</p>
<h5 id="（4）文件限制"><a href="#（4）文件限制" class="headerlink" title="（4）文件限制"></a>（4）文件限制</h5><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统<code>（file://）</code>，它所加载的脚本，必须来自网络。</p>
<h2 id="二、Worker的基础用法"><a href="#二、Worker的基础用法" class="headerlink" title="二、Worker的基础用法"></a>二、Worker的基础用法</h2><h3 id="2-1主线程"><a href="#2-1主线程" class="headerlink" title="2.1主线程"></a>2.1主线程</h3><p>新建一个Worer线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(&apos;work.js&apos;);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后主线程和子线程进行通信，主线程通过调用<code>postMessage</code>方法向子线程传递数据，传递的数据可以为任何的数据类型。</p>
<p>ps: 数据传递方式分为转让所有权和不转让所有权，区别会在下面详细说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&apos;Hello World&apos;);</span><br></pre></td></tr></table></figure>

<p>主线程通过<code>onmessage</code>指定监听函数，接受子线程发送回来的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">worker.onmessage= function(e)&#123;</span><br><span class="line">    console.log(&apos;onmessage&apos;, e.data)</span><br><span class="line">&#125;</span><br><span class="line">// 写法二</span><br><span class="line">worker.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(&apos;addEventListener&apos;, e.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件必须挂在worker下；上面代码中的<code>data</code>是获取<code>Worker</code>发送的数据。当<code>Worker</code>完成任务后，通过<code>terminate</code>关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>

<p>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作</p>
<h3 id="2-2-Worker线程"><a href="#2-2-Worker线程" class="headerlink" title="2.2 Worker线程"></a>2.2 Worker线程</h3><p>说完了主线程，就该说一下Worker线程如何进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// work.js</span><br><span class="line">// 接受数据</span><br><span class="line">self.onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">    self.postMessage(&apos;已拿到数据&apos;) // 给主线程发送数据</span><br><span class="line">    postMessage()</span><br><span class="line">&#125;</span><br><span class="line">onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line">self.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 执行完计算后可以关闭自身线程</span><br><span class="line">close()</span><br><span class="line">slef.close()</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>self</code>代表子线程本事，为子线程的全局对象。但是，在子线程中<code>this</code>为<code>undefined</code>，所以<code>this.onmessage</code>是不允许的。</p>
<p>当执行完运算后，worker线程也可以通过调用<code>close</code>方法进行关闭。同样的，执行完<code>close</code>后，worker 线程会被立即杀死，<code>close</code>之后的运行将不会进行。</p>
<h3 id="2-3-错误处理"><a href="#2-3-错误处理" class="headerlink" title="2.3 错误处理"></a>2.3 错误处理</h3><p>主线程可以监听Worker是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 主线程</span><br><span class="line">worker.onerror = function (event) &#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  console.log([</span><br><span class="line">    &apos;ERROR: Line &apos;, event.lineno, &apos; in &apos;, event.filename, &apos;: &apos;, event.message</span><br><span class="line">  ].join(&apos;&apos;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(&apos;error&apos;, function (event) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 <code>preventDefault()</code>方法。<br>在子线程中无法触发<code>onerror</code>事件。 </p>
<p><code>lineno</code>：发生错误时所在脚本文件的行号。</p>
<p><code>filename</code>：发生错误的脚本文件名。</p>
<p><code>message</code>：读性良好的错误消息。</p>
<h3 id="2-4-subWorker"><a href="#2-4-subWorker" class="headerlink" title="2.4 subWorker"></a>2.4 subWorker</h3><p>如果需要的话 worker能够生成更多的worker。这就是所谓的subworker，subWorker同样需要满足同源策略。而且，subworker解析URI时会相对于父worker的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p>
<h3 id="2-5-引入脚本与库"><a href="#2-5-引入脚本与库" class="headerlink" title="2.5 引入脚本与库"></a>2.5 引入脚本与库</h3><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；以下例子都是合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importScripts();                        /* 什么都不引入 */</span><br><span class="line">importScripts(&apos;foo.js&apos;);                /* 只引入 &quot;foo.js&quot; */</span><br><span class="line">importScripts(&apos;foo.js&apos;, &apos;bar.js&apos;);      /* 引入两个脚本 */</span><br></pre></td></tr></table></figure>

<p>浏览器加载并运行每一个列出的脚本。每个脚本中的全局对象都能够被 worker 使用。如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行。而之前执行的代码(包括使用 window.setTimeout() 异步执行的代码)依然能够运行。importScripts() 之后的函数声明依然会被保留，因为它们始终会在其他代码之前运行。</p>
<h3 id="2-6-SharedWorker"><a href="#2-6-SharedWorker" class="headerlink" title="2.6 SharedWorker"></a>2.6 SharedWorker</h3><p><code>SharedWorker</code>与普通的<code>worker</code>不一样，<code>SharedWorker</code>可以创建一个共享线程，使得多个页面可以共享一个worker线程。这里不做过多展开。</p>
<h2 id="三、Worker的数据通信"><a href="#三、Worker的数据通信" class="headerlink" title="三、Worker的数据通信"></a>三、Worker的数据通信</h2><p>上面在2.1的时候说到，worker的数据传递分为两种形式，转让所有权和不转让所有权。</p>
<p><strong>不转让所有权</strong>指的是主线程与worker通信的数据是通过深拷贝进行传值。 通常，主线程与worker进程通信的内容为文本或者对象，并且通常这种数据的大小不会大，所以这个时候通过拷贝的方式进行传值并不会太大影响。但是当数据量特别大的时候，就会影响到主线程的运行。</p>
<p><strong>转让所有权</strong>是一种性能更好的方法，<strong>可转让对象</strong>（Transferable Objects）从一个上下文转移到另一个上下文而不会经过任何拷贝操作。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 二进制</span><br><span class="line">var abBuffer = new ArrayBuffer(32);</span><br><span class="line">aDedicatedWorker.postMessage(abBuffer, [abBuffer]);</span><br><span class="line"></span><br><span class="line">// image</span><br><span class="line">var imageData = context.createImageData(img.width, img.height);</span><br><span class="line">// 转化为类型数组进行传递</span><br><span class="line">var int8s = new Int8Array(imageData.data);</span><br><span class="line">var data = &#123;</span><br><span class="line">    data: int8s,</span><br><span class="line">    width: imageData.width,</span><br><span class="line">    height: imageData.height</span><br><span class="line">&#125;;</span><br><span class="line">// 在postMessage方法的第二个参数中指定transferList</span><br><span class="line">work.postMessage(data, [data.data.buffer]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可转让对象支持的常用数据类型有<code>ArrayBuffer</code>和<code>ImageBitmap</code></p>
</blockquote>
<h2 id="四、Worker的线程问题"><a href="#四、Worker的线程问题" class="headerlink" title="四、Worker的线程问题"></a>四、Worker的线程问题</h2><p><code>Javascript</code>引擎是单线程运行的，<code>Worker</code>能够让<code>Javscript</code>进行多线程进行运行，是否就代表着<code>Javascript</code>就变成的一个支持多线程的语言了呢？</p>
<h3 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4.1 进程和线程"></a>4.1 进程和线程</h3><ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>浏览器是多进程的，每个进程包含了多个线程</li>
</ul>
<p><strong>为了方便理解，后续会忽略进程，只考虑线程，所以在某些细节上会存在一些不合理的地方</strong></p>
<h3 id="4-2-worker的线程"><a href="#4-2-worker的线程" class="headerlink" title="4.2 worker的线程"></a>4.2 worker的线程</h3><p><code>js</code>是运行在浏览器中的，浏览器是同时拥有多个线程的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程</span><br><span class="line">界面渲染线程（GUI渲染线程）</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br></pre></td></tr></table></figure>

<p>而<code>Web Worker</code>是浏览器提供的一个能力，通过相关API，<code>js</code>可以在浏览器中新开一个线程去运行<code>js</code>代码，最后的线程关系如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker线程</span><br></pre></td></tr></table></figure>

<p>所以，<code>Web Worker</code>并不代表着<code>js</code>这个语言就支持了多线程。</p>
<p><strong>WebWorker和SharedWorker的线程不一样，区别在于WebWorker线程只属于单个页面的线程，不会与其他页面共享；而SharedWorker的线程则是多个页面共享。这里不做更详细的讨论</strong></p>
<h3 id="4-3-worker异步和js异步有什么区别"><a href="#4-3-worker异步和js异步有什么区别" class="headerlink" title="4.3 worker异步和js异步有什么区别"></a>4.3 worker异步和js异步有什么区别</h3><p><code>JavaScript</code>中耗时的I/O操作都被处理为异步操作，它们包括键盘、鼠标I/O输入输出事件、窗口大小的<code>resize</code>事件、定时器(<code>setTimeout</code>、<code>setInterval</code>)事件、Ajax请求网络I/O回调等。当这些异步任务发生的时候，它们将会被放入浏览器的事件任务队列中去，等到<code>JavaScript</code>运行时执行线程空闲时候才会按照队列先进先出的原则被一一执行，但终究还是单线程，最后的处理还是放在了<strong>javascript引擎线程</strong>，假如异步处理中有复杂运算的时候，就很容易发生卡顿的情况。</p>
<p>但是，<code>web Worker</code>是通过创建一个新的线程进行运行`js``，两个进程之间只有在数据交换的时候才会进行通信。所以即使相关运算很复杂，也不会影响到主线程中的代码运行。</p>
<h3 id="4-4-连续创建多个Worker线程"><a href="#4-4-连续创建多个Worker线程" class="headerlink" title="4.4 连续创建多个Worker线程"></a>4.4 连续创建多个Worker线程</h3><p>如果在主线程中连续创建多个worker线程，这些worker线程在创建后就开始运行，不会互相影响，复杂运算也不用等待先创建的线程，关系如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker1线程</span><br><span class="line">Worker2线程</span><br><span class="line">Worker3线程</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在多个线程创建后，每个线程的运算都会同时进行</p>
<h3 id="4-4-创建Worker线程有上限么"><a href="#4-4-创建Worker线程有上限么" class="headerlink" title="4.4 创建Worker线程有上限么"></a>4.4 创建Worker线程有上限么</h3><p>在MDN中，并没有发现针对创建Worker上限的说法，本人也在google浏览器上实验过，也并尝试出浏览器针对同时创建多个worker线程的限制。所以猜测Worker的线程是依赖于运行的cpu能力。</p>
<h2 id="五、嵌入式worker"><a href="#五、嵌入式worker" class="headerlink" title="五、嵌入式worker"></a>五、嵌入式worker</h2><p>目前没有一种「官方」的方法能够像 <script> 元素一样将 worker 的代码嵌入的网页中。但是如果一个 <script> 元素没有 src 特性，并且它的 type 特性没有指定成一个可运行的 mime-type，那么它就会被认为是一个数据块元素，并且能够被 JavaScript 使用。「数据块」是 HTML5 中一个十分常见的特性，它可以携带几乎任何文本类型的数据。所以，你能够以如下方式嵌入一个 worker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;MDN Example - Embedded worker&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  var myVar = &quot;Hello World!&quot;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line">  function pageLog (sMsg) &#123;</span><br><span class="line">    // 使用 fragment：这样浏览器只会进行一次渲染/重排。</span><br><span class="line">    var oFragm = document.createDocumentFragment();</span><br><span class="line">    oFragm.appendChild(document.createTextNode(sMsg));</span><br><span class="line">    oFragm.appendChild(document.createElement(&quot;br&quot;));</span><br><span class="line">    document.querySelector(&quot;#logDisplay&quot;).appendChild(oFragm);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  onmessage = function (oEvent) &#123;</span><br><span class="line">    postMessage(myVar);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line"></span><br><span class="line">  // 在过去...：</span><br><span class="line">  // 我们使用 blob builder</span><br><span class="line">  // ...但是现在我们使用 Blob...:</span><br><span class="line">  var blob = new Blob(Array.prototype.map.call(document.querySelectorAll(&quot;script[type=\&quot;text\/js-worker\&quot;]&quot;), function (oScript) &#123; return oScript.textContent; &#125;),&#123;type: &quot;text/javascript&quot;&#125;);</span><br><span class="line"></span><br><span class="line">  // 创建一个新的 document.worker 属性，包含所有 &quot;text/js-worker&quot; 脚本。</span><br><span class="line">  document.worker = new Worker(window.URL.createObjectURL(blob));</span><br><span class="line"></span><br><span class="line">  document.worker.onmessage = function (oEvent) &#123;</span><br><span class="line">    pageLog(&quot;Received: &quot; + oEvent.data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 启动 worker.</span><br><span class="line">  window.onload = function() &#123; document.worker.postMessage(&quot;&quot;); &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;div id=&quot;logDisplay&quot;&gt;&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用嵌入式worker，无法在worker中新建worker</p>
</blockquote>
<h2 id="六、webpack中使用worker-loader"><a href="#六、webpack中使用worker-loader" class="headerlink" title="六、webpack中使用worker-loader"></a>六、webpack中使用worker-loader</h2><p>根据<strong>嵌入式web Worker</strong>原理，我们就可以在<code>webpack</code>应用中直接使用<code>web Worker</code>。</p>
<p>目前社区中已经有一个现成的轮子<code>worker-loader</code>可以直接使用了，下面就结合react 进行简单的说明。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i worker-loader --save</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack</code>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这里是使用了react-app-rewired</span><br><span class="line">module.exports = function override(config, env) &#123;</span><br><span class="line">  config.module.rules.push(&#123;</span><br><span class="line">      test: /\.worker\.js$/,   // 这个配置是匹配worker.js 结尾的文件</span><br><span class="line">      use: &#123; loader: &apos;worker-loader&apos; ,</span><br><span class="line">        options: &#123; inline: true &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    config.output.globalObject = &apos;this&apos;</span><br><span class="line">  return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import myWorker from &apos;./worker/file.worker.js&apos; // 根据配置规则，webWorker文件得用 worker.js 结尾</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const worker = new myWorker();</span><br><span class="line">worker.postMessage(&apos;init&apos;);</span><br><span class="line">worker.onmessage = function (event) &#123;&#125;;</span><br><span class="line">worker.addEventListener(&apos;message&apos;, event =&gt; &#123;</span><br><span class="line">  console.log(event.data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a href="https://www.npmjs.com/package/worker-loader">worker-loader说明</a></p>
<h2 id="七、worker的使用场景"><a href="#七、worker的使用场景" class="headerlink" title="七、worker的使用场景"></a>七、worker的使用场景</h2><p>简单说明一下worker的一些使用场景</p>
<ol>
<li>复杂的数学运算</li>
</ol>
<p>比如斐波那契数列计算，可以通过worker将复杂的计算分发到多个线程中，避免阻塞主线程。</p>
<ol start="2">
<li>图像处理</li>
</ol>
<p>通过使用从<code>&lt;canvas&gt;</code>或者<code>&lt;video&gt;</code>元素中获取的数据，可以把图像分割成个不同的区域并且把它们推送给并行的不同 Workers 来做计算</p>
<ol start="3">
<li>大量数据的检索</li>
</ol>
<p>当需要在调用 ajax后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在 Web Worker 中来做这些，避免冻结 UI 线程。</p>
<blockquote>
<p>后续我们将会有专门的一期<code>d3.js</code>与<code>worker</code>的结合使用的分享</p>
</blockquote>
<p><a href="https://github.com/caikaihao/webWorkerDemo">demo地址</a></p>
</script></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">东东</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://pengjiawen.我爱你/2019/08/26/webWorker/">http://pengjiawen.我爱你/2019/08/26/webWorker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/09/03/函数/"><i class="fa fa-chevron-left">  </i><span>函数</span></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 东东</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>