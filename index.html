<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="帅气的小哥哥"><meta name="keywords" content><meta name="author" content="东东"><meta name="copyright" content="东东"><title>好记性不如烂笔头 | 木皆白告</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://b-ssl.duitang.com/uploads/item/201711/10/20171110225150_ym2jw.jpeg"></div><div class="author-info__name text-center">东东</div><div class="author-info__description text-center">帅气的小哥哥</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">木皆白告</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">木皆白告</div><div id="site-sub-title">好记性不如烂笔头</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/16/nginx/">mac 安装nginx</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-16</time><div class="content"><blockquote>
<p>最近因为客户现场会进行nginx转发，为了保证客户现场的nginx转发没有问题，所以需要提前自测</p>
</blockquote>
<ol>
<li>安装brew<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里有提示目录不存在，要创建需要按return键，window下的回车键 安装成功后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 更新brew--&gt;</span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看安装信息--&gt;</span><br><span class="line">brew -v</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看是否安装了nginx--&gt;</span><br><span class="line">brew info nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装nginx<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>这两部分的安装都会花费比较长的时间</p>
</blockquote>
<ol start="3">
<li><p>nginx 相关命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--启动nginx--&gt;</span><br><span class="line">nginx</span><br><span class="line">&lt;!--重启nginx--&gt;</span><br><span class="line">nginx -s reload</span><br><span class="line">&lt;!--停止nginx--&gt;</span><br><span class="line">nginx -s strop</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看nginx的安装目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /usr/local/Cellar/nginx/</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看nginx的配置文件 nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /usr/local/etc/nginx/</span><br></pre></td></tr></table></figure>
</li>
<li><p>在nginx中添加代理，编辑器打开 nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改http里面的内容--&gt;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name server_name;</span><br><span class="line"></span><br><span class="line">    location /path &#123;</span><br><span class="line">      proxy_pass http://ip:port;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &lt;!--只需要重复添加server就能有不同的代理--&gt;</span><br><span class="line">    server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name server_name;</span><br><span class="line"></span><br><span class="line">    location /path &#123;</span><br><span class="line">      proxy_pass http://ip:port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>修改nginx.conf 后需要重启nginx</p>
</blockquote>
<ol start="7">
<li>解决 <code>ERR_CONTENT_LENGTH_MISMATCH</code>报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改nginx.conf--&gt;</span><br><span class="line">&lt;!--第一行--&gt;</span><br><span class="line">user root owner;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>修改后执行 <code>sudo nginx -s reload</code>，后续的启动都需要加上 <code>sudo</code> 命令</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/12/class相关的一些记录/">class相关的一些记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-12</time><div class="content"><h4 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h4><p>与 ES5 一样, 在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &apos;getter&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&apos;setter: &apos;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst = new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = 123;</span><br><span class="line">// setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">// &apos;getter&apos;</span><br></pre></td></tr></table></figure>

<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get html() &#123;</span><br><span class="line">    return this.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set html(value) &#123;</span><br><span class="line">    this.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, &quot;html&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&quot;get&quot; in descriptor  // true</span><br><span class="line">&quot;set&quot; in descriptor  // true</span><br></pre></td></tr></table></figure>

<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName();</span><br></pre></td></tr></table></figure>

<h4 id="静态属性（提案）"><a href="#静态属性（提案）" class="headerlink" title="静态属性（提案）"></a>静态属性（提案）</h4><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  static myStaticProp = 42;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(MyClass.myStaticProp); // 42</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="私有属性或者方法（提案）"><a href="#私有属性或者方法（提案）" class="headerlink" title="私有属性或者方法（提案）"></a>私有属性或者方法（提案）</h4><p>私有属性和私有方法都是在命名前面加 <code>#</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  #count = 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const counter = new IncreasingCounter();</span><br><span class="line">counter.#count // 报错</span><br><span class="line">counter.#count = 42 // 报错</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>子类的构造器中，必须执行<code>super</code>函数，并且<code>super</code>不能在其他类方法中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super() // 缺少会报错</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun () &#123;</span><br><span class="line">        super() // 在类方法中也会报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/03/函数/">函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-03</time><div class="content"><blockquote>
<p>好记性不如烂笔头</p>
</blockquote>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><blockquote>
<p>在函数调用时，arguments和this会被静默的传递给函数，并可以在函数体内引用它们，借以访问函数相关的一些信息。<br><br>其中arguments是一个类数组结构，它保存了调用时传递给函数的所有实参；this是函数执行时的上下文对象, 这个对象有些让人感到困惑的行为。 下面分别对他们进行讨论。</p>
</blockquote>
<h3 id="1-arguments"><a href="#1-arguments" class="headerlink" title="1 arguments"></a>1 arguments</h3><h4 id="1-1-arguments基础介绍"><a href="#1-1-arguments基础介绍" class="headerlink" title="1.1 arguments基础介绍"></a>1.1 arguments基础介绍</h4><p>JavaScript 允许函数在调用时传入的实参个数和函数定义时的形参个数不一致, 比如函数在定义时声明了 n 个参数, 在调用函数时不一定非要传入 n 个参数。当实参超过了形参改如何去拿到实参呢？这个时候就需要用到<code>arguments</code></p>
<p><code>arguments</code>是个类数组结构，它存储了函数在调用时传入的所有实参, 通过访问它的length属性可以得到其中保存的实参的个数，并可以通过arguments[n]按顺序取出传入的每个参数(n=1,2,..,arguments.length-1)。</p>
<blockquote>
<p>注意: arguments 的行为和属性虽然很像数组,但它并不是数组，只是一种类数组结构:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn(arg1,arg2)&#123;</span><br><span class="line">    console.log(arg1 === arguments[0]);  // true</span><br><span class="line">    console.log(arg2 === arguments[1]);  // true</span><br><span class="line">    console.log(arguments[2])</span><br><span class="line">    console.log(arguments[3])</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,&apos;b&apos;) // true true b undefined</span><br></pre></td></tr></table></figure>

<p>当传入实参超过了形参，就可以通过<code>arguments</code>去获得，这种情况下，<code>arguments</code>和对应的形参是一一对应的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn(arg1, arg2)&#123;</span><br><span class="line">    // 1. 修改arguments元素，对应的形参也会被修改</span><br><span class="line">    arguments[0] = &apos;修改了arguments&apos;;</span><br><span class="line">    console.log(arg1); </span><br><span class="line"></span><br><span class="line">    // 2. 修改形参值，对应的arguments也会被修改</span><br><span class="line">    arg2 = &apos;修改了形参值&apos;;</span><br><span class="line">    console.log(arguments[1]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1,2);</span><br><span class="line">// &apos;修改了arguments&apos;</span><br><span class="line">// &apos;修改了形参值&apos;</span><br></pre></td></tr></table></figure>

<p>如果是严格模式下就不存在这种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;; // 启用严格模式</span><br><span class="line">function fn(arg1, arg2)&#123;</span><br><span class="line">    // 修改arguments元素，对应的形参也会被修改</span><br><span class="line">    arguments[0] = &apos;修改了arguments&apos;;</span><br><span class="line">    console.log(arg1);</span><br><span class="line"></span><br><span class="line">    // 修改形参值，对应的arguments也会被修改</span><br><span class="line">    arg2 = &apos;修改了形参值&apos;;</span><br><span class="line">    console.log(arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1,2);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<h3 id="1-2-ES6-解构与-arguments"><a href="#1-2-ES6-解构与-arguments" class="headerlink" title="1.2 ES6 解构与 arguments"></a>1.2 ES6 解构与 arguments</h3><p>在ES6中, 可以用灵活性更强的解构的方式(…符号)获得函数调用时传入的实参,而且通过这种方式获得的实参是保存在真正的数组中的，解构可以和普通的形参混用，但是解构参数必须为最后一个。混用规则是，形参剩下的参数传入进解构参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(a, ...args)&#123; // 通过解构的方式得到实参</span><br><span class="line">    console.log(args instanceof Array);  // args 是真正的数组</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(args);  // 而且 args 中也保存了传入的实参</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1,2,3);</span><br><span class="line">// true</span><br><span class="line">// 1</span><br><span class="line">// Array(2) [2, 3]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结构参数必须为最后一个。</p>
</blockquote>
<h3 id="2-函数上下文：this"><a href="#2-函数上下文：this" class="headerlink" title="2. 函数上下文：this"></a>2. 函数上下文：this</h3><p>在函数调用时, 函数体内也可以访问到this参数,它代表了和函数调用相关联的对象,被称为函数上下文</p>
<p>this的指向受到函数调用方式的影响, 而函数的调用方式可以分成以下4种:</p>
<ol>
<li>直接调用, 例如: fn()</li>
<li>作为对象的方法被调用, 例如: obj.fn()</li>
<li>被当做一个构造函数来使用, 例如: new Fn()</li>
<li>通过函数 call() 或者 apply() 调用, 例如: obj.apply(fn) / obj.call(fn)</li>
</ol>
<h4 id="2-1-直接调用一个函数时-this-的指向"><a href="#2-1-直接调用一个函数时-this-的指向" class="headerlink" title="2.1 直接调用一个函数时 this 的指向"></a>2.1 直接调用一个函数时 this 的指向</h4><p>在非严格模式下, this值会指向全局上下文(例如在浏览器中是<code>window</code>,Node.js环境下是<code>global</code>)。而在严格模式下, this 的值是 undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  // global || Window</span><br><span class="line"></span><br><span class="line">// 严格模式</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); // undefined</span><br></pre></td></tr></table></figure>

<h4 id="2-2-被一个对象当做方法调用"><a href="#2-2-被一个对象当做方法调用" class="headerlink" title="2.2 被一个对象当做方法调用"></a>2.2 被一个对象当做方法调用</h4><p>当函数被一个对象当成方法调用时, 这个函数的 this 会指向调用它的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个对象</span><br><span class="line">let xm = &#123;</span><br><span class="line">    getThis ()&#123; // 定义一个函数</span><br><span class="line">        return this;  // 这个函数返回自己的 this 指向</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let thisOfFunc = xm.getThis();  // 通过对象调用函数得到函数的 this 指向</span><br><span class="line">console.log(thisOfFunc === xm); // true, 函数的this指向调用它的对象本身</span><br></pre></td></tr></table></figure>

<h4 id="2-3-被作为构造函数来调用时"><a href="#2-3-被作为构造函数来调用时" class="headerlink" title="2.3 被作为构造函数来调用时"></a>2.3 被作为构造函数来调用时</h4><h5 id="2-3-1-使用构造函数创建对象时发生了什么"><a href="#2-3-1-使用构造函数创建对象时发生了什么" class="headerlink" title="2.3.1 使用构造函数创建对象时发生了什么"></a>2.3.1 使用构造函数创建对象时发生了什么</h5><ol>
<li>创建一个空对象 {}</li>
<li>将该对象的prototype链接到构造函数的prototype上</li>
<li>将这个新对象作为 this 的指向</li>
<li>如果这个构造函数没有返回一个引用类型的值, 则将上面构造的新对象返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    this.getThis = function()&#123; // 这个函数返回 this</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person() // window</span><br><span class="line"></span><br><span class="line">let p1 = new Person(); // 调用了构造函数并返回了一个新的对象，输出一个新的对象</span><br><span class="line">console.log(p1.getThis() === p1); // true</span><br><span class="line"></span><br><span class="line">let p2 = new Person();</span><br><span class="line">console.log(p2.getThis() === p2); //  true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-4-通过-call-或者-apply-调用时"><a href="#2-4-通过-call-或者-apply-调用时" class="headerlink" title="2.4 通过 call() 或者 apply() 调用时"></a>2.4 通过 call() 或者 apply() 调用时</h4><p>使用函数 call 和 apply 可以在调用一个函数时指定这个函数的 this 的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn.call(targetThis, arg1, arg2,..., argN)</span><br><span class="line">fn.apply(targetThis, [arg1, arg2,.., argN])</span><br><span class="line"></span><br><span class="line">fn: 要调用的函数</span><br><span class="line">targetThis: 要把 fn 的 this 设置到的目标</span><br><span class="line">argument: 要给 fn 传的实参</span><br></pre></td></tr></table></figure>

<p>example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let xm = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xm.sayName();  // 对象调用函数输出 &apos;小明&apos;</span><br><span class="line">let xh = &#123;</span><br><span class="line">    name: &apos;小红&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xm.sayName.call(xh);  // 小红</span><br><span class="line">xm.sayName.apply(xh);  // 小红</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-call-和-apply-的区别"><a href="#2-4-1-call-和-apply-的区别" class="headerlink" title="2.4.1 call 和 apply 的区别"></a>2.4.1 call 和 apply 的区别</h4><p>call 和 apply 的区别仅仅是要传给fn的参数的形式不同:对于apply,传给fn的参数argument是个数组,数组由所有参数组成;对于call,传给fn的参数argument直接是所有参数的排列, 直接一个个写入就可以。<br>例如要传给函数fn三个参数: 1、2、3. 则对于 call和apply调用的方法分别是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(targetThis, 1, 2, 3); // 把 1,2,3直接传入</span><br><span class="line">fn.apply(targetThis, [1,2,3]); // 把1,2,3合成数组后作为参数</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的this指向为创建时候的上下文环境的this，或者说定义时的作用域链的上一层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用function函数</span><br><span class="line">function Person()&#123;</span><br><span class="line">    this.age = 24;</span><br><span class="line">  </span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.age); // undefined</span><br><span class="line">      console.log(this === window); // true</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var p = new Person(); // 创建一个实例的时候就立即执行了定时器</span><br><span class="line">  </span><br><span class="line"> // 使用箭头函数</span><br><span class="line">function Person()&#123;</span><br><span class="line">    this.age = 24;</span><br><span class="line">    </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this.age); // 24</span><br><span class="line">        console.log(this === p); // true</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure>

<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind函数的作用是根据一个旧函数而创建一个新函数，语法为<code>newFn = oldFn.bind(thisTarget)</code>。它会将旧函数复制一份作为新函数, 然后将新函数的<code>thi</code>s永远绑定到<code>thisTarget</code>指向的上下文中, 然后返回这个新函数, 以后每次调用这个新函数时, 无论用什么方法都无法改变这个新函数的 this 指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个对象有 name 和 sayName 属性</span><br><span class="line">let p1 = &#123;</span><br><span class="line">    name: &apos;P1&apos;,</span><br><span class="line">    sayName()&#123; </span><br><span class="line">        console.log(this.name); // 访问函数指向的 this 的 name 属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p1.sayName(); // P1</span><br><span class="line"></span><br><span class="line">// 创建一个对象 p2, 并把这个对象作为bind函数绑定的this</span><br><span class="line">let p2 = &#123;</span><br><span class="line">    name: &apos;P2&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 将p1的 sayName 函数的 this 绑定到 p2 上, 生成新函数 sayP2Name 并返回</span><br><span class="line">let sayP2Name = p1.sayName.bind(p2); </span><br><span class="line"></span><br><span class="line">// 由于此时 sayP2Name 的内部 this 已经绑定了 p2, </span><br><span class="line">// 所以即使是按 文章2.1部分 所说的直接调用 sayP2Name, 它的 this 也是指向 p2 的, 并不是指向全局上下文或者 undefined</span><br><span class="line">sayP2Name();  // P2</span><br><span class="line"></span><br><span class="line">// 定义新对象, 尝试将 sayP2Name 的 this 指向到 p3 上</span><br><span class="line">let p3 = &#123;</span><br><span class="line">    name: &apos;P3&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 尝试使用 call和apply 函数来将 sayP2Name 函数的 this 指向p3,</span><br><span class="line">// 但是由于 sayP2Name 函数的this 已经被bind函数永远绑定到p2上了, 所以this.name仍然是p2.name</span><br><span class="line">sayP2Name.call(p3); // P2</span><br><span class="line">sayP2Name.apply(p3); // P2</span><br><span class="line">// 再一次使用bind</span><br><span class="line">sayP2Name = sayP2Name.bind(p3)</span><br><span class="line">sayP2Name() // p2</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/26/webWorker/">webWokrer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-26</time><div class="content"><h2 id="一、webWokrer介绍"><a href="#一、webWokrer介绍" class="headerlink" title="一、webWokrer介绍"></a>一、<code>webWokrer</code>介绍</h2><p>javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。</p>
<p>web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，子线程不会影响到主线程程序的运行，这样就能提高对计算机的运算能力的利用。</p>
<h5 id="1-1-web-worker需要注意的几个小点"><a href="#1-1-web-worker需要注意的几个小点" class="headerlink" title="1.1 web worker需要注意的几个小点"></a>1.1 web worker需要注意的几个小点</h5><h5 id="（1）同源策略"><a href="#（1）同源策略" class="headerlink" title="（1）同源策略"></a>（1）同源策略</h5><p>webWorker脚本必须和主线程的脚本同源</p>
<h5 id="（2）全局对象限制"><a href="#（2）全局对象限制" class="headerlink" title="（2）全局对象限制"></a>（2）全局对象限制</h5><p>webWorker脚本所在的全局对象，与主线程不一致，无法使用：</p>
<p><code>docement</code>、 <code>window</code>、 <code>parent</code>、 <code>DOM</code>对象，这样即代表着webWorker不能更新DOM节点；并且webWorker不能执行<code>alert()</code>方法和<code>confirm()</code>方法，</p>
<p>但是可以使用：</p>
<p><code>navigator</code>、<code>location</code>（只读）、<code>XMLHttpRequest</code>（可以创建AJAX请求） 、<code>setTimeout/setInterval</code> 方法、<code>Application Cache</code>、通过 <code>importScripts()</code>方法加载其他脚本、创建新的 Web Worker</p>
<h5 id="（3）通信限制"><a href="#（3）通信限制" class="headerlink" title="（3）通信限制"></a>（3）通信限制</h5><p>Worker线程和主线程不在同一个上下文环境，之间不能直接通信，只能通过消息事件进行通信，这里的传递只是进行值传递（拷贝传递），而不是进行引用地址传递，这种方法叫做结构化克隆传递数据（structured cloning）。</p>
<p>在进行二进制传递的时候，是使用可转让对象传递数据（transferable objects），即主线程把二进制数据直接转让给了子进程，此时主进程将无法使用此部分二进制数据，反过来亦如此。这是为了防止出现多个线程同时修改数据的问题。</p>
<h5 id="（4）文件限制"><a href="#（4）文件限制" class="headerlink" title="（4）文件限制"></a>（4）文件限制</h5><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统<code>（file://）</code>，它所加载的脚本，必须来自网络。</p>
<h2 id="二、Worker的基础用法"><a href="#二、Worker的基础用法" class="headerlink" title="二、Worker的基础用法"></a>二、Worker的基础用法</h2><h3 id="2-1主线程"><a href="#2-1主线程" class="headerlink" title="2.1主线程"></a>2.1主线程</h3><p>新建一个Worer线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(&apos;work.js&apos;);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后主线程和子线程进行通信，主线程通过调用<code>postMessage</code>方法向子线程传递数据，传递的数据可以为任何的数据类型。</p>
<p>ps: 数据传递方式分为转让所有权和不转让所有权，区别会在下面详细说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&apos;Hello World&apos;);</span><br></pre></td></tr></table></figure>

<p>主线程通过<code>onmessage</code>指定监听函数，接受子线程发送回来的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">worker.onmessage= function(e)&#123;</span><br><span class="line">    console.log(&apos;onmessage&apos;, e.data)</span><br><span class="line">&#125;</span><br><span class="line">// 写法二</span><br><span class="line">worker.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(&apos;addEventListener&apos;, e.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件必须挂在worker下；上面代码中的<code>data</code>是获取<code>Worker</code>发送的数据。当<code>Worker</code>完成任务后，通过<code>terminate</code>关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>

<p>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作</p>
<h3 id="2-2-Worker线程"><a href="#2-2-Worker线程" class="headerlink" title="2.2 Worker线程"></a>2.2 Worker线程</h3><p>说完了主线程，就该说一下Worker线程如何进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// work.js</span><br><span class="line">// 接受数据</span><br><span class="line">self.onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">    self.postMessage(&apos;已拿到数据&apos;) // 给主线程发送数据</span><br><span class="line">    postMessage()</span><br><span class="line">&#125;</span><br><span class="line">onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line">self.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 执行完计算后可以关闭自身线程</span><br><span class="line">close()</span><br><span class="line">slef.close()</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>self</code>代表子线程本事，为子线程的全局对象。但是，在子线程中<code>this</code>为<code>undefined</code>，所以<code>this.onmessage</code>是不允许的。</p>
<p>当执行完运算后，worker线程也可以通过调用<code>close</code>方法进行关闭。同样的，执行完<code>close</code>后，worker 线程会被立即杀死，<code>close</code>之后的运行将不会进行。</p>
<h3 id="2-3-错误处理"><a href="#2-3-错误处理" class="headerlink" title="2.3 错误处理"></a>2.3 错误处理</h3><p>主线程可以监听Worker是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 主线程</span><br><span class="line">worker.onerror = function (event) &#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  console.log([</span><br><span class="line">    &apos;ERROR: Line &apos;, event.lineno, &apos; in &apos;, event.filename, &apos;: &apos;, event.message</span><br><span class="line">  ].join(&apos;&apos;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(&apos;error&apos;, function (event) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 <code>preventDefault()</code>方法。<br>在子线程中无法触发<code>onerror</code>事件。 </p>
<p><code>lineno</code>：发生错误时所在脚本文件的行号。</p>
<p><code>filename</code>：发生错误的脚本文件名。</p>
<p><code>message</code>：读性良好的错误消息。</p>
<h3 id="2-4-subWorker"><a href="#2-4-subWorker" class="headerlink" title="2.4 subWorker"></a>2.4 subWorker</h3><p>如果需要的话 worker能够生成更多的worker。这就是所谓的subworker，subWorker同样需要满足同源策略。而且，subworker解析URI时会相对于父worker的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p>
<h3 id="2-5-引入脚本与库"><a href="#2-5-引入脚本与库" class="headerlink" title="2.5 引入脚本与库"></a>2.5 引入脚本与库</h3><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；以下例子都是合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importScripts();                        /* 什么都不引入 */</span><br><span class="line">importScripts(&apos;foo.js&apos;);                /* 只引入 &quot;foo.js&quot; */</span><br><span class="line">importScripts(&apos;foo.js&apos;, &apos;bar.js&apos;);      /* 引入两个脚本 */</span><br></pre></td></tr></table></figure>

<p>浏览器加载并运行每一个列出的脚本。每个脚本中的全局对象都能够被 worker 使用。如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行。而之前执行的代码(包括使用 window.setTimeout() 异步执行的代码)依然能够运行。importScripts() 之后的函数声明依然会被保留，因为它们始终会在其他代码之前运行。</p>
<h3 id="2-6-SharedWorker"><a href="#2-6-SharedWorker" class="headerlink" title="2.6 SharedWorker"></a>2.6 SharedWorker</h3><p><code>SharedWorker</code>与普通的<code>worker</code>不一样，<code>SharedWorker</code>可以创建一个共享线程，使得多个页面可以共享一个worker线程。这里不做过多展开。</p>
<h2 id="三、Worker的数据通信"><a href="#三、Worker的数据通信" class="headerlink" title="三、Worker的数据通信"></a>三、Worker的数据通信</h2><p>上面在2.1的时候说到，worker的数据传递分为两种形式，转让所有权和不转让所有权。</p>
<p><strong>不转让所有权</strong>指的是主线程与worker通信的数据是通过深拷贝进行传值。 通常，主线程与worker进程通信的内容为文本或者对象，并且通常这种数据的大小不会大，所以这个时候通过拷贝的方式进行传值并不会太大影响。但是当数据量特别大的时候，就会影响到主线程的运行。</p>
<p><strong>转让所有权</strong>是一种性能更好的方法，<strong>可转让对象</strong>（Transferable Objects）从一个上下文转移到另一个上下文而不会经过任何拷贝操作。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 二进制</span><br><span class="line">var abBuffer = new ArrayBuffer(32);</span><br><span class="line">aDedicatedWorker.postMessage(abBuffer, [abBuffer]);</span><br><span class="line"></span><br><span class="line">// image</span><br><span class="line">var imageData = context.createImageData(img.width, img.height);</span><br><span class="line">// 转化为类型数组进行传递</span><br><span class="line">var int8s = new Int8Array(imageData.data);</span><br><span class="line">var data = &#123;</span><br><span class="line">    data: int8s,</span><br><span class="line">    width: imageData.width,</span><br><span class="line">    height: imageData.height</span><br><span class="line">&#125;;</span><br><span class="line">// 在postMessage方法的第二个参数中指定transferList</span><br><span class="line">work.postMessage(data, [data.data.buffer]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可转让对象支持的常用数据类型有<code>ArrayBuffer</code>和<code>ImageBitmap</code></p>
</blockquote>
<h2 id="四、Worker的线程问题"><a href="#四、Worker的线程问题" class="headerlink" title="四、Worker的线程问题"></a>四、Worker的线程问题</h2><p><code>Javascript</code>引擎是单线程运行的，<code>Worker</code>能够让<code>Javscript</code>进行多线程进行运行，是否就代表着<code>Javascript</code>就变成的一个支持多线程的语言了呢？</p>
<h3 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4.1 进程和线程"></a>4.1 进程和线程</h3><ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>浏览器是多进程的，每个进程包含了多个线程</li>
</ul>
<p><strong>为了方便理解，后续会忽略进程，只考虑线程，所以在某些细节上会存在一些不合理的地方</strong></p>
<h3 id="4-2-worker的线程"><a href="#4-2-worker的线程" class="headerlink" title="4.2 worker的线程"></a>4.2 worker的线程</h3><p><code>js</code>是运行在浏览器中的，浏览器是同时拥有多个线程的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程</span><br><span class="line">界面渲染线程（GUI渲染线程）</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br></pre></td></tr></table></figure>

<p>而<code>Web Worker</code>是浏览器提供的一个能力，通过相关API，<code>js</code>可以在浏览器中新开一个线程去运行<code>js</code>代码，最后的线程关系如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker线程</span><br></pre></td></tr></table></figure>

<p>所以，<code>Web Worker</code>并不代表着<code>js</code>这个语言就支持了多线程。</p>
<p><strong>WebWorker和SharedWorker的线程不一样，区别在于WebWorker线程只属于单个页面的线程，不会与其他页面共享；而SharedWorker的线程则是多个页面共享。这里不做更详细的讨论</strong></p>
<h3 id="4-3-worker异步和js异步有什么区别"><a href="#4-3-worker异步和js异步有什么区别" class="headerlink" title="4.3 worker异步和js异步有什么区别"></a>4.3 worker异步和js异步有什么区别</h3><p><code>JavaScript</code>中耗时的I/O操作都被处理为异步操作，它们包括键盘、鼠标I/O输入输出事件、窗口大小的<code>resize</code>事件、定时器(<code>setTimeout</code>、<code>setInterval</code>)事件、Ajax请求网络I/O回调等。当这些异步任务发生的时候，它们将会被放入浏览器的事件任务队列中去，等到<code>JavaScript</code>运行时执行线程空闲时候才会按照队列先进先出的原则被一一执行，但终究还是单线程，最后的处理还是放在了<strong>javascript引擎线程</strong>，假如异步处理中有复杂运算的时候，就很容易发生卡顿的情况。</p>
<p>但是，<code>web Worker</code>是通过创建一个新的线程进行运行`js``，两个进程之间只有在数据交换的时候才会进行通信。所以即使相关运算很复杂，也不会影响到主线程中的代码运行。</p>
<h3 id="4-4-连续创建多个Worker线程"><a href="#4-4-连续创建多个Worker线程" class="headerlink" title="4.4 连续创建多个Worker线程"></a>4.4 连续创建多个Worker线程</h3><p>如果在主线程中连续创建多个worker线程，这些worker线程在创建后就开始运行，不会互相影响，复杂运算也不用等待先创建的线程，关系如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker1线程</span><br><span class="line">Worker2线程</span><br><span class="line">Worker3线程</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在多个线程创建后，每个线程的运算都会同时进行</p>
<h3 id="4-4-创建Worker线程有上限么"><a href="#4-4-创建Worker线程有上限么" class="headerlink" title="4.4 创建Worker线程有上限么"></a>4.4 创建Worker线程有上限么</h3><p>在MDN中，并没有发现针对创建Worker上限的说法，本人也在google浏览器上实验过，也并尝试出浏览器针对同时创建多个worker线程的限制。所以猜测Worker的线程是依赖于运行的cpu能力。</p>
<h2 id="五、嵌入式worker"><a href="#五、嵌入式worker" class="headerlink" title="五、嵌入式worker"></a>五、嵌入式worker</h2><p>目前没有一种「官方」的方法能够像 <script> 元素一样将 worker 的代码嵌入的网页中。但是如果一个 <script> 元素没有 src 特性，并且它的 type 特性没有指定成一个可运行的 mime-type，那么它就会被认为是一个数据块元素，并且能够被 JavaScript 使用。「数据块」是 HTML5 中一个十分常见的特性，它可以携带几乎任何文本类型的数据。所以，你能够以如下方式嵌入一个 worker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;MDN Example - Embedded worker&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  var myVar = &quot;Hello World!&quot;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line">  function pageLog (sMsg) &#123;</span><br><span class="line">    // 使用 fragment：这样浏览器只会进行一次渲染/重排。</span><br><span class="line">    var oFragm = document.createDocumentFragment();</span><br><span class="line">    oFragm.appendChild(document.createTextNode(sMsg));</span><br><span class="line">    oFragm.appendChild(document.createElement(&quot;br&quot;));</span><br><span class="line">    document.querySelector(&quot;#logDisplay&quot;).appendChild(oFragm);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  onmessage = function (oEvent) &#123;</span><br><span class="line">    postMessage(myVar);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line"></span><br><span class="line">  // 在过去...：</span><br><span class="line">  // 我们使用 blob builder</span><br><span class="line">  // ...但是现在我们使用 Blob...:</span><br><span class="line">  var blob = new Blob(Array.prototype.map.call(document.querySelectorAll(&quot;script[type=\&quot;text\/js-worker\&quot;]&quot;), function (oScript) &#123; return oScript.textContent; &#125;),&#123;type: &quot;text/javascript&quot;&#125;);</span><br><span class="line"></span><br><span class="line">  // 创建一个新的 document.worker 属性，包含所有 &quot;text/js-worker&quot; 脚本。</span><br><span class="line">  document.worker = new Worker(window.URL.createObjectURL(blob));</span><br><span class="line"></span><br><span class="line">  document.worker.onmessage = function (oEvent) &#123;</span><br><span class="line">    pageLog(&quot;Received: &quot; + oEvent.data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 启动 worker.</span><br><span class="line">  window.onload = function() &#123; document.worker.postMessage(&quot;&quot;); &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;div id=&quot;logDisplay&quot;&gt;&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用嵌入式worker，无法在worker中新建worker</p>
</blockquote>
<h2 id="六、webpack中使用worker-loader"><a href="#六、webpack中使用worker-loader" class="headerlink" title="六、webpack中使用worker-loader"></a>六、webpack中使用worker-loader</h2><p>根据<strong>嵌入式web Worker</strong>原理，我们就可以在<code>webpack</code>应用中直接使用<code>web Worker</code>。</p>
<p>目前社区中已经有一个现成的轮子<code>worker-loader</code>可以直接使用了，下面就结合react 进行简单的说明。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i worker-loader --save</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack</code>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这里是使用了react-app-rewired</span><br><span class="line">module.exports = function override(config, env) &#123;</span><br><span class="line">  config.module.rules.push(&#123;</span><br><span class="line">      test: /\.worker\.js$/,   // 这个配置是匹配worker.js 结尾的文件</span><br><span class="line">      use: &#123; loader: &apos;worker-loader&apos; ,</span><br><span class="line">        options: &#123; inline: true &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    config.output.globalObject = &apos;this&apos;</span><br><span class="line">  return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import myWorker from &apos;./worker/file.worker.js&apos; // 根据配置规则，webWorker文件得用 worker.js 结尾</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const worker = new myWorker();</span><br><span class="line">worker.postMessage(&apos;init&apos;);</span><br><span class="line">worker.onmessage = function (event) &#123;&#125;;</span><br><span class="line">worker.addEventListener(&apos;message&apos;, event =&gt; &#123;</span><br><span class="line">  console.log(event.data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a href="https://www.npmjs.com/package/worker-loader">worker-loader说明</a></p>
<h2 id="七、worker的使用场景"><a href="#七、worker的使用场景" class="headerlink" title="七、worker的使用场景"></a>七、worker的使用场景</h2><p>简单说明一下worker的一些使用场景</p>
<ol>
<li>复杂的数学运算</li>
</ol>
<p>比如斐波那契数列计算，可以通过worker将复杂的计算分发到多个线程中，避免阻塞主线程。</p>
<ol start="2">
<li>图像处理</li>
</ol>
<p>通过使用从<code>&lt;canvas&gt;</code>或者<code>&lt;video&gt;</code>元素中获取的数据，可以把图像分割成个不同的区域并且把它们推送给并行的不同 Workers 来做计算</p>
<ol start="3">
<li>大量数据的检索</li>
</ol>
<p>当需要在调用 ajax后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在 Web Worker 中来做这些，避免冻结 UI 线程。</p>
<blockquote>
<p>后续我们将会有专门的一期<code>d3.js</code>与<code>worker</code>的结合使用的分享</p>
</blockquote>
<p><a href="https://github.com/caikaihao/webWorkerDemo">demo地址</a></p>
</script></p></div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 东东</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>