<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>webWokrer | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、webWokrer介绍javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。 web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，">
<meta property="og:type" content="article">
<meta property="og:title" content="webWokrer">
<meta property="og:url" content="http://pengjiawen.我爱你/2019/08/26/webWorker/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、webWokrer介绍javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。 web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-26T12:45:08.149Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="webWokrer">
<meta name="twitter:description" content="一、webWokrer介绍javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。 web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://pengjiawen.我爱你"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-webWorker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/26/webWorker/" class="article-date">
  <time datetime="2019-08-26T12:44:09.011Z" itemprop="datePublished">2019-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      webWokrer
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、webWokrer介绍"><a href="#一、webWokrer介绍" class="headerlink" title="一、webWokrer介绍"></a>一、<code>webWokrer</code>介绍</h2><p>javascript 是一种单线程语言，即所有任务只能在一个线程上完成，一次只能完成一个任务，如果前面的任务没有完成，后面的任务将无法执行。到目前为止，计算机的运算能力已经得到了极大的提升，单线程无法充分利用起计算机的运算能力。</p>
<p>web Worker 是HTML5 标准的一部分,这一规范定义了一套API，运行一段javascript 程序运行在主线程之外的另一个线程之中，子线程不会影响到主线程程序的运行，这样就能提高对计算机的运算能力的利用。</p>
<h5 id="1-1-web-worker需要注意的几个小点"><a href="#1-1-web-worker需要注意的几个小点" class="headerlink" title="1.1 web worker需要注意的几个小点"></a>1.1 web worker需要注意的几个小点</h5><h5 id="（1）同源策略"><a href="#（1）同源策略" class="headerlink" title="（1）同源策略"></a>（1）同源策略</h5><p>webWorker脚本必须和主线程的脚本同源</p>
<h5 id="（2）全局对象限制"><a href="#（2）全局对象限制" class="headerlink" title="（2）全局对象限制"></a>（2）全局对象限制</h5><p>webWorker脚本所在的全局对象，与主线程不一致，无法使用：</p>
<p><code>docement</code>、 <code>window</code>、 <code>parent</code>、 <code>DOM</code>对象，这样即代表着webWorker不能更新DOM节点；并且webWorker不能执行<code>alert()</code>方法和<code>confirm()</code>方法，</p>
<p>但是可以使用：</p>
<p><code>navigator</code>、<code>location</code>（只读）、<code>XMLHttpRequest</code>（可以创建AJAX请求） 、<code>setTimeout/setInterval</code> 方法、<code>Application Cache</code>、通过 <code>importScripts()</code>方法加载其他脚本、创建新的 Web Worker</p>
<h5 id="（3）通信限制"><a href="#（3）通信限制" class="headerlink" title="（3）通信限制"></a>（3）通信限制</h5><p>Worker线程和主线程不在同一个上下文环境，之间不能直接通信，只能通过消息事件进行通信，这里的传递只是进行值传递（拷贝传递），而不是进行引用地址传递，这种方法叫做结构化克隆传递数据（structured cloning）。</p>
<p>在进行二进制传递的时候，是使用可转让对象传递数据（transferable objects），即主线程把二进制数据直接转让给了子进程，此时主进程将无法使用此部分二进制数据，反过来亦如此。这是为了防止出现多个线程同时修改数据的问题。</p>
<h5 id="（4）文件限制"><a href="#（4）文件限制" class="headerlink" title="（4）文件限制"></a>（4）文件限制</h5><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统<code>（file://）</code>，它所加载的脚本，必须来自网络。</p>
<h2 id="二、Worker的基础用法"><a href="#二、Worker的基础用法" class="headerlink" title="二、Worker的基础用法"></a>二、Worker的基础用法</h2><h3 id="2-1主线程"><a href="#2-1主线程" class="headerlink" title="2.1主线程"></a>2.1主线程</h3><p>新建一个Worer线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(&apos;work.js&apos;);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后主线程和子线程进行通信，主线程通过调用<code>postMessage</code>方法向子线程传递数据，传递的数据可以为任何的数据类型。</p>
<p>ps: 数据传递方式分为转让所有权和不转让所有权，区别会在下面详细说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&apos;Hello World&apos;);</span><br></pre></td></tr></table></figure>

<p>主线程通过<code>onmessage</code>指定监听函数，接受子线程发送回来的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">worker.onmessage= function(e)&#123;</span><br><span class="line">    console.log(&apos;onmessage&apos;, e.data)</span><br><span class="line">&#125;</span><br><span class="line">// 写法二</span><br><span class="line">worker.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(&apos;addEventListener&apos;, e.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件必须挂在worker下；上面代码中的<code>data</code>是获取<code>Worker</code>发送的数据。当<code>Worker</code>完成任务后，通过<code>terminate</code>关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>

<p>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作</p>
<h3 id="2-2-Worker线程"><a href="#2-2-Worker线程" class="headerlink" title="2.2 Worker线程"></a>2.2 Worker线程</h3><p>说完了主线程，就该说一下Worker线程如何进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// work.js</span><br><span class="line">// 接受数据</span><br><span class="line">self.onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">    self.postMessage(&apos;已拿到数据&apos;) // 给主线程发送数据</span><br><span class="line">    postMessage()</span><br><span class="line">&#125;</span><br><span class="line">onmessage = function(e)&#123; </span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line">self.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 执行完计算后可以关闭自身线程</span><br><span class="line">close()</span><br><span class="line">slef.close()</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>self</code>代表子线程本事，为子线程的全局对象。但是，在子线程中<code>this</code>为<code>undefined</code>，所以<code>this.onmessage</code>是不允许的。</p>
<p>当执行完运算后，worker线程也可以通过调用<code>close</code>方法进行关闭。同样的，执行完<code>close</code>后，worker 线程会被立即杀死，<code>close</code>之后的运行将不会进行。</p>
<h3 id="2-3-错误处理"><a href="#2-3-错误处理" class="headerlink" title="2.3 错误处理"></a>2.3 错误处理</h3><p>主线程可以监听Worker是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 主线程</span><br><span class="line">worker.onerror = function (event) &#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  console.log([</span><br><span class="line">    &apos;ERROR: Line &apos;, event.lineno, &apos; in &apos;, event.filename, &apos;: &apos;, event.message</span><br><span class="line">  ].join(&apos;&apos;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(&apos;error&apos;, function (event) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 <code>preventDefault()</code>方法。<br>在子线程中无法触发<code>onerror</code>事件。 </p>
<p><code>lineno</code>：发生错误时所在脚本文件的行号。</p>
<p><code>filename</code>：发生错误的脚本文件名。</p>
<p><code>message</code>：读性良好的错误消息。</p>
<h3 id="2-4-subWorker"><a href="#2-4-subWorker" class="headerlink" title="2.4 subWorker"></a>2.4 subWorker</h3><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；以下例子都是合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importScripts();                        /* 什么都不引入 */</span><br><span class="line">importScripts(&apos;foo.js&apos;);                /* 只引入 &quot;foo.js&quot; */</span><br><span class="line">importScripts(&apos;foo.js&apos;, &apos;bar.js&apos;);      /* 引入两个脚本 */</span><br></pre></td></tr></table></figure>

<p>浏览器加载并运行每一个列出的脚本。每个脚本中的全局对象都能够被 worker 使用。如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行。而之前执行的代码(包括使用 window.setTimeout() 异步执行的代码)依然能够运行。importScripts() 之后的函数声明依然会被保留，因为它们始终会在其他代码之前运行。</p>
<h3 id="2-5-SharedWorker"><a href="#2-5-SharedWorker" class="headerlink" title="2.5 SharedWorker"></a>2.5 SharedWorker</h3><h2 id="三、Worker的数据通信"><a href="#三、Worker的数据通信" class="headerlink" title="三、Worker的数据通信"></a>三、Worker的数据通信</h2><p>上面在2.1的时候说到，worker的数据传递分为两种形式，转让所有权和不转让所有权。</p>
<p><strong>不转让所有权</strong>指的是主线程与worker通信的数据是通过深拷贝进行传值。 通常，主线程与worker进程通信的内容为文本或者对象，并且通常这种数据的大小不会大，所以这个时候通过拷贝的方式进行传值并不会太大影响。但是当数据量特别大的时候，就会影响到主线程的运行。</p>
<p><strong>转让所有权</strong>是一种性能更好的方法，<strong>可转让对象</strong>（Transferable Objects）从一个上下文转移到另一个上下文而不会经过任何拷贝操作。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 二进制</span><br><span class="line">var abBuffer = new ArrayBuffer(32);</span><br><span class="line">aDedicatedWorker.postMessage(abBuffer, [abBuffer]);</span><br><span class="line"></span><br><span class="line">// image</span><br><span class="line">var imageData = context.createImageData(img.width, img.height);</span><br><span class="line">// 转化为类型数组进行传递</span><br><span class="line">var int8s = new Int8Array(imageData.data);</span><br><span class="line">var data = &#123;</span><br><span class="line">    data: int8s,</span><br><span class="line">    width: imageData.width,</span><br><span class="line">    height: imageData.height</span><br><span class="line">&#125;;</span><br><span class="line">// 在postMessage方法的第二个参数中指定transferList</span><br><span class="line">work.postMessage(data, [data.data.buffer]);</span><br></pre></td></tr></table></figure>

<p>ps:可转让对象支持的常用数据类型有<code>ArrayBuffer</code>和<code>ImageBitmap</code></p>
<h2 id="四、Worker的线程问题"><a href="#四、Worker的线程问题" class="headerlink" title="四、Worker的线程问题"></a>四、Worker的线程问题</h2><p><code>Javascript</code>引擎是单线程运行的，<code>Worker</code>能够让<code>Javscript</code>进行多线程进行运行，是否就代表着<code>Javascript</code>就变成的一个支持多线程的语言了呢？</p>
<h3 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4.1 进程和线程"></a>4.1 进程和线程</h3><ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>浏览器是多进程的，每个进程包含了多个线程</li>
</ul>
<p><strong>为了方便理解，后续会忽略进程，只考虑线程，所以在某些细节上会存在一些不合理的地方</strong></p>
<h3 id="4-2-worker的线程"><a href="#4-2-worker的线程" class="headerlink" title="4.2 worker的线程"></a>4.2 worker的线程</h3><p><code>js</code>是运行在浏览器中的，浏览器是同时拥有多个线程的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程</span><br><span class="line">界面渲染线程（GUI渲染线程）</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br></pre></td></tr></table></figure>

<p>而<code>Web Worker</code>是浏览器提供的一个能力，通过相关API，<code>js</code>可以在浏览器中新开一个线程去运行<code>js</code>代码，最后的线程关系如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker线程</span><br></pre></td></tr></table></figure>

<p>所以，<code>Web Worker</code>并不代表着<code>js</code>这个语言就支持了多线程。</p>
<p><strong>WebWorker和SharedWorker的线程不一样，区别在于WebWorker线程只属于单个页面的线程，不会与其他页面共享；而SharedWorker的线程则是多个页面共享。这里不做更详细的讨论</strong></p>
<h3 id="4-3-worker异步和js异步有什么区别"><a href="#4-3-worker异步和js异步有什么区别" class="headerlink" title="4.3 worker异步和js异步有什么区别"></a>4.3 worker异步和js异步有什么区别</h3><p><code>JavaScript</code>中耗时的I/O操作都被处理为异步操作，它们包括键盘、鼠标I/O输入输出事件、窗口大小的<code>resize</code>事件、定时器(<code>setTimeout</code>、<code>setInterval</code>)事件、Ajax请求网络I/O回调等。当这些异步任务发生的时候，它们将会被放入浏览器的事件任务队列中去，等到<code>JavaScript</code>运行时执行线程空闲时候才会按照队列先进先出的原则被一一执行，但终究还是单线程，最后的处理还是放在了<strong>javascript引擎线程</strong>，假如异步处理中有复杂运算的时候，就很容易发生卡顿的情况。</p>
<p>但是，<code>web Worker</code>是通过创建一个新的线程进行运行`js``，两个进程之间只有在数据交换的时候才会进行通信。所以即使相关运算很复杂，也不会影响到主线程中的代码运行。</p>
<h3 id="4-4-连续创建多个Worker线程"><a href="#4-4-连续创建多个Worker线程" class="headerlink" title="4.4 连续创建多个Worker线程"></a>4.4 连续创建多个Worker线程</h3><p>如果在主线程中连续创建多个worker线程，这些worker线程在创建后就开始运行，不会互相影响，复杂运算也不用等待先创建的线程，关系如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript引擎线程（主线程）</span><br><span class="line">界面渲染线程</span><br><span class="line">浏览器事件触发线程</span><br><span class="line">Http请求线程</span><br><span class="line">Worker1线程</span><br><span class="line">Worker2线程</span><br><span class="line">Worker3线程</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在多个线程创建后，每个线程的运算都会同时进行</p>
<h3 id="4-4-创建Worker线程有上限么"><a href="#4-4-创建Worker线程有上限么" class="headerlink" title="4.4 创建Worker线程有上限么"></a>4.4 创建Worker线程有上限么</h3><p>在MDN中，并没有发现针对创建Worker上限的说法，本人也在google浏览器上实验过，也并尝试出浏览器针对同时创建多个worker线程的限制。所以猜测Worker的线程是依赖于运行的cpu能力。</p>
<h2 id="五、嵌入式worker"><a href="#五、嵌入式worker" class="headerlink" title="五、嵌入式worker"></a>五、嵌入式worker</h2><p>目前没有一种「官方」的方法能够像 <script> 元素一样将 worker 的代码嵌入的网页中。但是如果一个 <script> 元素没有 src 特性，并且它的 type 特性没有指定成一个可运行的 mime-type，那么它就会被认为是一个数据块元素，并且能够被 JavaScript 使用。「数据块」是 HTML5 中一个十分常见的特性，它可以携带几乎任何文本类型的数据。所以，你能够以如下方式嵌入一个 worker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;MDN Example - Embedded worker&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  var myVar = &quot;Hello World!&quot;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line">  function pageLog (sMsg) &#123;</span><br><span class="line">    // 使用 fragment：这样浏览器只会进行一次渲染/重排。</span><br><span class="line">    var oFragm = document.createDocumentFragment();</span><br><span class="line">    oFragm.appendChild(document.createTextNode(sMsg));</span><br><span class="line">    oFragm.appendChild(document.createElement(&quot;br&quot;));</span><br><span class="line">    document.querySelector(&quot;#logDisplay&quot;).appendChild(oFragm);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/js-worker&quot;&gt;</span><br><span class="line">  // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。</span><br><span class="line">  onmessage = function (oEvent) &#123;</span><br><span class="line">    postMessage(myVar);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 剩下的 worker 代码写到这里。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。</span><br><span class="line"></span><br><span class="line">  // 在过去...：</span><br><span class="line">  // 我们使用 blob builder</span><br><span class="line">  // ...但是现在我们使用 Blob...:</span><br><span class="line">  var blob = new Blob(Array.prototype.map.call(document.querySelectorAll(&quot;script[type=\&quot;text\/js-worker\&quot;]&quot;), function (oScript) &#123; return oScript.textContent; &#125;),&#123;type: &quot;text/javascript&quot;&#125;);</span><br><span class="line"></span><br><span class="line">  // 创建一个新的 document.worker 属性，包含所有 &quot;text/js-worker&quot; 脚本。</span><br><span class="line">  document.worker = new Worker(window.URL.createObjectURL(blob));</span><br><span class="line"></span><br><span class="line">  document.worker.onmessage = function (oEvent) &#123;</span><br><span class="line">    pageLog(&quot;Received: &quot; + oEvent.data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 启动 worker.</span><br><span class="line">  window.onload = function() &#123; document.worker.postMessage(&quot;&quot;); &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;div id=&quot;logDisplay&quot;&gt;&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、webpack中使用worker"><a href="#六、webpack中使用worker" class="headerlink" title="六、webpack中使用worker"></a>六、webpack中使用worker</h2></script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://pengjiawen.我爱你/2019/08/26/webWorker/" data-id="cjzsgbkfl0001jd1cz7w10c0k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/08/26/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/26/webWorker/">webWokrer</a>
          </li>
        
          <li>
            <a href="/2019/08/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>